"""Semantic validation data models."""

import uuid
from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, ConfigDict, Field, field_validator


class ValidationIssue(BaseModel):
    """Individual issue detected by semantic validation."""

    issue_id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique identifier for issue"
    )
    type: Literal[
        "specificity", "relevance", "consistency", "hallucination", "do_say_mismatch"
    ] = Field(..., description="Issue type")
    severity: Literal["LOW", "MEDIUM", "HIGH", "CRITICAL"] = Field(
        ..., description="Severity (determined by LLM)"
    )
    description: str = Field(..., description="Human-readable issue explanation")
    location: Optional[Dict[str, Any]] = Field(
        default=None, description="Where issue was detected (step_id, artifact reference)"
    )
    proposed_repair: Optional[Dict[str, Any]] = Field(
        default=None, description="Suggested fix generated by LLM"
    )

    @field_validator("issue_id", "description")
    @classmethod
    def validate_non_empty(cls, v: str) -> str:
        """Validate that string fields are non-empty."""
        if not v or not v.strip():
            raise ValueError("Field cannot be empty")
        return v.strip()

    model_config = ConfigDict(
        frozen=False,
        json_schema_extra={
            "example": {
                "issue_id": "123e4567-e89b-12d3-a456-426614174000",
                "type": "specificity",
                "severity": "MEDIUM",
                "description": "Step description is too vague",
                "location": {"step_id": "step_1"},
                "proposed_repair": {"description": "More specific description"}
            }
        }
    )


class SemanticValidationReport(BaseModel):
    """Output from semantic validation layer identifying semantic quality issues."""

    validation_id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique identifier for validation run"
    )
    artifact_type: Literal[
        "plan", "step", "execution_artifact", "cross_phase"
    ] = Field(..., description="Type of artifact validated")
    issues: List[ValidationIssue] = Field(
        default_factory=list, description="Array of detected issues"
    )
    overall_severity: Literal["LOW", "MEDIUM", "HIGH", "CRITICAL"] = Field(
        default="LOW", description="Highest severity detected"
    )
    issue_summary: Dict[str, int] = Field(
        default_factory=dict, description="Counts by issue type"
    )
    proposed_repairs: List[Dict[str, Any]] = Field(
        default_factory=list, description="Array of repair suggestions"
    )

    @field_validator("validation_id")
    @classmethod
    def validate_non_empty(cls, v: str) -> str:
        """Validate that validation_id is non-empty."""
        if not v or not v.strip():
            raise ValueError("validation_id cannot be empty")
        return v.strip()

    def _calculate_overall_severity(self) -> Literal["LOW", "MEDIUM", "HIGH", "CRITICAL"]:
        """Calculate overall severity from issues."""
        if not self.issues:
            return "LOW"
        
        severity_order = {"LOW": 0, "MEDIUM": 1, "HIGH": 2, "CRITICAL": 3}
        max_severity = max(
            (severity_order.get(issue.severity, 0) for issue in self.issues),
            default=0
        )
        
        for severity, value in severity_order.items():
            if value == max_severity:
                return severity
        
        return "LOW"

    def _calculate_issue_summary(self) -> Dict[str, int]:
        """Calculate issue counts by type."""
        summary: Dict[str, int] = {}
        for issue in self.issues:
            summary[issue.type] = summary.get(issue.type, 0) + 1
        return summary

    def _collect_proposed_repairs(self) -> List[Dict[str, Any]]:
        """Collect proposed repairs from issues."""
        repairs = []
        for issue in self.issues:
            if issue.proposed_repair:
                repairs.append({
                    "issue_id": issue.issue_id,
                    "issue_type": issue.type,
                    "repair": issue.proposed_repair
                })
        return repairs

    def model_post_init(self, __context: Any) -> None:
        """Update calculated fields after initialization."""
        if self.issues:
            self.overall_severity = self._calculate_overall_severity()
            self.issue_summary = self._calculate_issue_summary()
            self.proposed_repairs = self._collect_proposed_repairs()

    model_config = ConfigDict(
        frozen=False,
        json_schema_extra={
            "example": {
                "validation_id": "123e4567-e89b-12d3-a456-426614174000",
                "artifact_type": "plan",
                "issues": [],
                "overall_severity": "LOW",
                "issue_summary": {},
                "proposed_repairs": []
            }
        }
    )

